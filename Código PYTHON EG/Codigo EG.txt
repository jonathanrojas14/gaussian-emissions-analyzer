"""
gaussian_ch4.py — Gaussian plume (single continuous point source) + inversion for Q (emission rate).
Author: ChatGPT (engineer mode)
Requirements: python>=3.9, numpy, pandas, matplotlib (for optional plots)
Usage examples:
    # From another script or notebook
    from gaussian_ch4 import (
        gaussian_concentration, invert_emission_rate, pasquill_sigma,
        latlon_to_local_xy, rotate_to_wind_frame, simulate_dataset
    )

    # CLI (quick test using synthetic data)
    python gaussian_ch4.py --demo

Core references: textbook Gaussian plume formulation. The sigmas parameterization is provided as
a pragmatic set of defaults; tune to site-specific conditions when field data are available.
"""

import numpy as np
import pandas as pd
from dataclasses import dataclass
from typing import Tuple, Literal, Optional, Dict

# -----------------------------
# Coordinate utilities
# -----------------------------

EARTH_R = 6371000.0  # meters

def latlon_to_local_xy(lat: np.ndarray, lon: np.ndarray,
                       lat0: float, lon0: float) -> Tuple[np.ndarray, np.ndarray]:
    """
    Convert lat/lon to local tangent-plane x (east), y (north) in meters
    using an equirectangular approximation suitable for small domains (< few km).
    """
    lat_rad = np.radians(lat)
    lon_rad = np.radians(lon)
    lat0_rad = np.radians(lat0)
    lon0_rad = np.radians(lon0)

    dlon = lon_rad - lon0_rad
    dlat = lat_rad - lat0_rad
    x = EARTH_R * dlon * np.cos((lat_rad + lat0_rad) / 2.0)
    y = EARTH_R * dlat
    return x, y

def rotate_to_wind_frame(x_local: np.ndarray, y_local: np.ndarray,
                         wind_dir_from_deg: float) -> Tuple[np.ndarray, np.ndarray]:
    """
    Rotate local coordinates so that x' is along the downwind direction.
    wind_dir_from_deg is the meteorological 'from' direction (0 = from North, 90 = from East).
    Downwind (towards) direction = wind_dir_from_deg + 180 deg.
    """
    theta = np.radians((wind_dir_from_deg + 180.0) % 360.0)
    # Rotate coordinates by -theta (so x' aligns with downwind)
    cos_t, sin_t = np.cos(theta), np.sin(theta)
    x_prime =  cos_t * x_local + sin_t * y_local
    y_prime = -sin_t * x_local + cos_t * y_local
    return x_prime, y_prime

# -----------------------------
# Sigma parameterization
# -----------------------------

@dataclass
class SigmaParams:
    # sigma_y = a_y * x^b_y
    # sigma_z = a_z * x^b_z
    a_y: float
    b_y: float
    a_z: float
    b_z: float

# Pragmatic defaults (order-of-magnitude, neutral-to-slightly-convective values).
# Tune with site data. These power-law fits are smooth and avoid discontinuities.
SIGMA_TABLE: Dict[str, SigmaParams] = {
    "A": SigmaParams(a_y=0.32, b_y=0.78, a_z=0.24, b_z=0.74),
    "B": SigmaParams(a_y=0.32, b_y=0.70, a_z=0.24, b_z=0.68),
    "C": SigmaParams(a_y=0.22, b_y=0.68, a_z=0.20, b_z=0.70),
    "D": SigmaParams(a_y=0.16, b_y=0.65, a_z=0.14, b_z=0.68),
    "E": SigmaParams(a_y=0.11, b_y=0.62, a_z=0.08, b_z=0.68),
    "F": SigmaParams(a_y=0.08, b_y=0.60, a_z=0.06, b_z=0.65),
}

def pasquill_sigma(x_m: np.ndarray,
                   stability_class: Literal["A","B","C","D","E","F"]="D") -> Tuple[np.ndarray, np.ndarray]:
    """
    Compute (sigma_y, sigma_z) in meters given downwind distance x (m).
    Uses smooth power-law fits per stability class; valid for x >= 1 m.
    """
    p = SIGMA_TABLE[stability_class]
    x = np.maximum(x_m, 1.0)
    sigma_y = p.a_y * np.power(x, p.b_y)
    sigma_z = p.a_z * np.power(x, p.b_z)
    return sigma_y, sigma_z

# -----------------------------
# Gaussian plume (continuous point source)
# -----------------------------

def gaussian_concentration(Q_gps: float,
                           x: np.ndarray, y: np.ndarray, z: np.ndarray,
                           u_ms: np.ndarray,
                           H_m: float,
                           sigma_y: np.ndarray, sigma_z: np.ndarray) -> np.ndarray:
    """
    Compute concentration anomaly (arbitrary units proportional to Q, e.g., ppm above background)
    for a continuous point source with ground reflection (image source) term.
    The formula assumes stationarity and homogeneity during the averaging interval.
    """
    # Avoid division by zero
    u = np.maximum(u_ms, 0.1)
    sigy = np.maximum(sigma_y, 0.01)
    sigz = np.maximum(sigma_z, 0.01)

    pref = Q_gps / (2.0 * np.pi * u * sigy * sigz)
    term_y = np.exp(- (y ** 2) / (2.0 * sigy ** 2))
    term_z = np.exp(- ((z - H_m) ** 2) / (2.0 * sigz ** 2)) + np.exp(- ((z + H_m) ** 2) / (2.0 * sigz ** 2))

    C = pref * term_y * term_z
    # For upwind (x<=0), the simple steady plume model is not valid; set to ~0
    C = np.where(x > 0, C, 0.0)
    return C

# -----------------------------
# Inversion for Q (linear least squares with weights)
# -----------------------------

def invert_emission_rate(
        x: np.ndarray, y: np.ndarray, z: np.ndarray,
        u_ms: np.ndarray, H_m: float,
        dC: np.ndarray,
        sigma_y: np.ndarray, sigma_z: np.ndarray,
        weights: Optional[np.ndarray] = None
    ) -> Tuple[float, float, float]:
    """
    Solve for Q in C = G * Q  (linear in Q), using weighted least squares.
    Returns (Q_hat, Q_std, r2).
    """
    u = np.maximum(u_ms, 0.1)
    sigy = np.maximum(sigma_y, 0.01)
    sigz = np.maximum(sigma_z, 0.01)

    G = (1.0 / (2.0 * np.pi * u * sigy * sigz)) * \
        np.exp(- (y ** 2) / (2.0 * sigy ** 2)) * \
        (np.exp(- ((z - H_m) ** 2) / (2.0 * sigz ** 2)) + np.exp(- ((z + H_m) ** 2) / (2.0 * sigz ** 2)))

    mask = (x > 0) & np.isfinite(G) & np.isfinite(dC)
    G = G[mask]
    yv = dC[mask]
    if weights is not None:
        w = weights[mask]
        W = np.diag(w)
        GTW = G.T @ W
        Q_hat = float(np.linalg.pinv(GTW @ G) @ (GTW @ yv))
        y_pred = G * Q_hat
        resid = yv - y_pred
        dof = max(len(yv) - 1, 1)
        s2 = float((resid.T @ (W @ resid)) / dof)
        covQ = s2 * np.linalg.pinv(GTW @ G)
        Q_std = float(np.sqrt(covQ))
    else:
        G2 = G[:, None]  # Nx1
        Q_hat = float(np.linalg.pinv(G2).dot(yv))
        y_pred = G * Q_hat
        resid = yv - y_pred
        dof = max(len(yv) - 1, 1)
        s2 = float((resid @ resid) / dof)
        # Var(Q) = s2 * (G^T G)^-1 for 1-parameter LSQ
        Q_std = float(np.sqrt(s2 / np.maximum(np.sum(G * G), 1e-12)))

    # R^2
    ss_res = float(np.sum((yv - y_pred) ** 2))
    ss_tot = float(np.sum((yv - np.mean(yv)) ** 2)) if len(yv) > 1 else 0.0
    r2 = 1.0 - ss_res / ss_tot if ss_tot > 0 else 0.0
    return Q_hat, Q_std, r2

# -----------------------------
# Synthetic dataset generator
# -----------------------------

def simulate_dataset(n_points: int = 500,
                     Q_true_gps: float = 0.25,       # g/s ≈ 900 g/h
                     lat0: float = 7.1300, lon0: float = -73.1250,
                     H_m: float = 2.0,
                     z_sensor_m: float = 1.5,
                     wind_speed_ms: float = 4.0,
                     wind_dir_from_deg: float = 270.0,
                     stability: str = "D",
                     background_ppm: float = 1.90,
                     noise_ppm: float = 0.02,
                     domain_m: float = 300.0,
                     seed: int = 42) -> pd.DataFrame:
    """
    Create a synthetic van-lab/transect dataset around a source at (lat0, lon0).
    Returns a DataFrame with columns suitable for inversion.
    """
    rng = np.random.default_rng(seed)

    # Random sampling points around the source within a square domain
    dx = rng.uniform(-domain_m, domain_m, n_points)
    dy = rng.uniform(-domain_m, domain_m, n_points)

    # Convert to pseudo lat/lon for convenience
    dlat = dy / EARTH_R
    dlon = dx / (EARTH_R * np.cos(np.radians(lat0)))
    lat = lat0 + np.degrees(dlat)
    lon = lon0 + np.degrees(dlon)

    # Rotate to wind frame
    xw, yw = rotate_to_wind_frame(dx, dy, wind_dir_from_deg)

    # Sigmas and model
    sigy, sigz = pasquill_sigma(np.abs(xw), stability)
    C_model = gaussian_concentration(
        Q_true_gps, xw, yw, np.full_like(xw, z_sensor_m),
        np.full_like(xw, wind_speed_ms), H_m, sigy, sigz
    )

    # Convert anomaly to "ppm-like" units by applying a scale factor S (arbitrary)
    # Here we assume 1 unit of model concentration equals 1 ppm anomaly for simplicity.
    dC_ppm = C_model

    # Add background and noise
    noise = rng.normal(0.0, noise_ppm, size=n_points)
    ch4_ppm = background_ppm + dC_ppm + noise

    df = pd.DataFrame({
        "lat": lat,
        "lon": lon,
        "z_m": np.full(n_points, z_sensor_m),
        "ch4_ppm": ch4_ppm,
        "background_ppm": np.full(n_points, background_ppm),
        "wind_speed_ms": np.full(n_points, wind_speed_ms),
        "wind_dir_from_deg": np.full(n_points, wind_dir_from_deg),
        "stability": np.full(n_points, stability),
        "source_lat": np.full(n_points, lat0),
        "source_lon": np.full(n_points, lon0),
        "source_height_m": np.full(n_points, H_m),
        "Q_true_gps": np.full(n_points, Q_true_gps),
    })
    return df

# -----------------------------
# High-level pipeline
# -----------------------------

def preprocess_and_invert(df: pd.DataFrame,
                          stability_override: Optional[str] = None,
                          wind_sector_half_width_deg: float = 30.0) -> Dict[str, float]:
    """
    End-to-end: compute local coords, rotate to wind frame, compute sigmas,
    build anomaly, filter points within wind sector, then invert for Q.
    """
    # Coordinates relative to source
    x_local, y_local = latlon_to_local_xy(df["lat"].values, df["lon"].values,
                                          df["source_lat"].values[0], df["source_lon"].values[0])

    # Bearing from source to point (for sector filter)
    bearings_deg = (np.degrees(np.arctan2(x_local, y_local)) + 360.0) % 360.0  # 0=N, 90=E
    wind_from = float(df["wind_dir_from_deg"].iloc[0])
    wind_towards = (wind_from + 180.0) % 360.0
    # Angular difference
    ang_diff = np.abs(((bearings_deg - wind_towards + 180.0) % 360.0) - 180.0)

    # Rotate to wind frame
    xw, yw = rotate_to_wind_frame(x_local, y_local, wind_from)

    # Build anomaly
    dC = (df["ch4_ppm"] - df["background_ppm"]).values
    z = df["z_m"].values
    u = df["wind_speed_ms"].values
    H = float(df["source_height_m"].iloc[0])

    # Sigmas
    stab = stability_override or str(df["stability"].iloc[0])
    sigy, sigz = pasquill_sigma(np.abs(xw), stab)

    # Filter: downwind, inside sector, finite
    mask = (xw > 0) & (ang_diff <= wind_sector_half_width_deg) & np.isfinite(dC) & np.isfinite(u)
    if mask.sum() < 5:
        raise ValueError("Insufficient valid downwind points after filtering. Try relaxing the sector or check inputs.")

    Q_hat, Q_std, r2 = invert_emission_rate(xw[mask], yw[mask], z[mask], u[mask], H,
                                            dC[mask], sigy[mask], sigz[mask], weights=None)
    return {
        "Q_hat_gps": Q_hat,
        "Q_std_gps": Q_std,
        "Q_hat_gph": Q_hat * 3600.0,
        "Q_std_gph": Q_std * 3600.0,
        "R2": r2,
        "n_points": int(mask.sum()),
        "stability_used": stab
    }

# -----------------------------
# CLI demo
# -----------------------------

def _demo():
    df = simulate_dataset(n_points=800, Q_true_gps=0.25, stability="D")
    stats = preprocess_and_invert(df, stability_override=None)
    print("=== DEMO (synthetic) ===")
    print(f"True Q: {df['Q_true_gps'].iloc[0]:.3f} g/s  ({df['Q_true_gps'].iloc[0]*3600:.1f} g/h)")
    print(f"Est  Q: {stats['Q_hat_gps']:.3f} ± {stats['Q_std_gps']:.3f} g/s  "
          f"({stats['Q_hat_gph']:.1f} ± {stats['Q_std_gph']:.1f} g/h)")
    print(f"R2: {stats['R2']:.3f}   n={stats['n_points']}   stability={stats['stability_used']}")

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--demo", action="store_true", help="Run a synthetic demo and print Q estimate.")
    args = ap.parse_args()
    if args.demo:
        _demo()
