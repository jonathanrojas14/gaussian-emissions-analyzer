import os
from flask import Flask, render_template, request, jsonify
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from gaussian_ch4 import preprocess_and_invert
import json

app = Flask(__name__)

# Asegurarse de que existe el directorio para subir archivos
UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'})
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'})
    
    if file and file.filename.endswith('.csv'):
        # Leer el CSV
        df = pd.read_csv(file)
        
        # Imprimir columnas para debug
        print("Columnas detectadas:", df.columns.tolist())
        print("Primeras filas:", df.head())
        
        try:
            # Normalizar nombres de columnas (eliminar espacios extras)
            df.columns = df.columns.str.strip()
            
            # Mapear columnas con nombres alternativos
            column_mapping = {}
            for col in df.columns:
                col_lower = col.lower().replace(' ', '_')
                if 'lat' in col_lower and 'source' not in col_lower:
                    column_mapping[col] = 'lat'
                elif 'lon' in col_lower and 'source' not in col_lower:
                    column_mapping[col] = 'lon'
                elif 'ch4' in col_lower and 'ppm' in col_lower:
                    column_mapping[col] = 'ch4_ppm'
                elif 'background' in col_lower:
                    column_mapping[col] = 'background_ppm'
                elif 'wind_speed' in col_lower or 'wind speed' in col_lower:
                    column_mapping[col] = 'wind_speed_ms'
                elif 'wind_dir' in col_lower or 'wind dir' in col_lower:
                    column_mapping[col] = 'wind_dir_from_deg'
                elif 'stability' in col_lower:
                    column_mapping[col] = 'stability'
                elif 'source_lat' in col_lower:
                    column_mapping[col] = 'source_lat'
                elif 'source_lon' in col_lower:
                    column_mapping[col] = 'source_lon'
                elif 'source_height' in col_lower:
                    column_mapping[col] = 'source_height_m'
                elif col_lower == 'z_m':
                    column_mapping[col] = 'z_m'
                elif 'q_true' in col_lower:
                    column_mapping[col] = 'Q_true_gps'
            
            # Renombrar columnas
            if column_mapping:
                df.rename(columns=column_mapping, inplace=True)
            
            print("Columnas después de normalizar:", df.columns.tolist())
            
            # Procesar los datos usando el modelo gaussiano
            results = preprocess_and_invert(df)
            
            # Crear gráficas
            # 1. Mapa de dispersión con concentraciones de CH4
            fig_scatter = px.scatter_mapbox(df, 
                                   lat='lat', 
                                   lon='lon', 
                                   color='ch4_ppm',
                                   size='ch4_ppm',
                                   hover_data=['ch4_ppm', 'wind_speed_ms'],
                                   color_continuous_scale='Jet',
                                   title='Mapa de Concentraciones de CH4',
                                   zoom=14)
            fig_scatter.update_layout(
                mapbox_style="open-street-map",
                height=500,
                margin={"r":0,"t":30,"l":0,"b":0}
            )
            
            # 2. Gráfica 2D alternativa si mapbox falla
            fig_scatter_2d = px.scatter(df, 
                                   x='lon', 
                                   y='lat', 
                                   color='ch4_ppm',
                                   size='ch4_ppm',
                                   hover_data=['ch4_ppm', 'wind_speed_ms'],
                                   color_continuous_scale='Jet',
                                   title='Mapa de Concentraciones de CH4',
                                   labels={'lon': 'Longitud', 'lat': 'Latitud', 'ch4_ppm': 'CH4 (ppm)'})
            fig_scatter_2d.update_layout(height=500)
            
            # 3. Rosa de vientos mejorada
            if 'wind_dir_from_deg' in df.columns:
                wind_counts = df.groupby('wind_dir_from_deg').size()
                wind_rose = go.Figure(go.Barpolar(
                    r=wind_counts.values,
                    theta=wind_counts.index,
                    name='Frecuencia',
                    marker_color='rgb(106,81,163)',
                    marker_line_color="rgb(8,48,107)",
                    marker_line_width=1.5,
                    opacity=0.8
                ))
                wind_rose.update_layout(
                    title='Rosa de Vientos',
                    polar=dict(
                        radialaxis=dict(visible=True),
                        angularaxis=dict(direction="clockwise")
                    ),
                    height=500
                )
            else:
                # Rosa de vientos placeholder
                wind_rose = go.Figure()
                wind_rose.update_layout(title='Rosa de Vientos - No hay datos disponibles')
            
            # 4. Serie temporal de CH4
            if 'ch4_ppm' in df.columns:
                fig_timeseries = go.Figure()
                fig_timeseries.add_trace(go.Scatter(
                    y=df['ch4_ppm'],
                    mode='lines+markers',
                    name='CH4',
                    line=dict(color='green', width=2)
                ))
                fig_timeseries.update_layout(
                    title='Serie Temporal de Concentraciones CH4',
                    xaxis_title='Índice de Muestra',
                    yaxis_title='CH4 (ppm)',
                    height=400
                )
            else:
                fig_timeseries = go.Figure()
                fig_timeseries.update_layout(title='Serie Temporal - No disponible')
            
            # Preparar respuesta
            response_data = {
                'results': results,
                'scatter_plot': json.loads(fig_scatter.to_json()),
                'scatter_plot_2d': json.loads(fig_scatter_2d.to_json()),
                'wind_rose': json.loads(wind_rose.to_json()),
                'timeseries': json.loads(fig_timeseries.to_json()),
                'data_summary': {
                    'total_points': len(df),
                    'ch4_mean': float(df['ch4_ppm'].mean()) if 'ch4_ppm' in df.columns else 0,
                    'ch4_max': float(df['ch4_ppm'].max()) if 'ch4_ppm' in df.columns else 0,
                    'ch4_min': float(df['ch4_ppm'].min()) if 'ch4_ppm' in df.columns else 0,
                    'columns': list(df.columns)
                },
                'success': True
            }
            
            return jsonify(response_data)
            
        except Exception as e:
            return jsonify({'error': str(e), 'columns': list(df.columns) if 'df' in locals() else []})
    
    return jsonify({'error': 'Invalid file type'})

if __name__ == '__main__':
    app.run(debug=True, port=5000)